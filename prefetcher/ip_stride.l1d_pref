#include "cache.h"

// ------------------------- DO NOT CHANGE -------------------------------- //
#define IP_TRACKER_COUNT 64           // Number of IP trackers
#define PREFETCH_DEGREE 5             // Prefetch degree
// ------------------------- DO NOT CHANGE -------------------------------- //

class IP_TRACKER {
  public:
    // ------------------------- Define the IP_TRACKER class here ------------------------- //
    uint64_t ip;
    uint64_t last_cl_addr;
    int64_t last_stride;
    int lru;
    int conf;     //confidence of stride

    IP_TRACKER(){
      ip=0;
      last_cl_addr=0;
      last_stride=0;
      lru=63;
      conf=0;
    }
    
};

IP_TRACKER trackers[IP_TRACKER_COUNT];

// ------------------------- Initialize the prefetcher ------------------------- // 
void CACHE::l1d_prefetcher_initialize() 
{
	cout << "CPU " << cpu << " L1D IP-based stride prefetcher" << endl;
  for (int i=0; i<IP_TRACKER_COUNT; i++)               // #YVR  To initialize the IP trackers
      trackers[i].lru = i;                             //       LRU values for each tracker in ip table

}

// --------------- This is the main prefetcher operate function ---------------- // 
void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint8_t critical_ip_flag)
{
    uint64_t cl_addr = addr >> LOG2_BLOCK_SIZE;

    // ------------------------ Add IP-Stride pf_address logic here ----------------------- // 

    int index=-1;
    for(index=0;index<IP_TRACKER_COUNT;index++){
      if(trackers[index].ip == ip){                   //#YVR To check if the ip is present in the tracker or not
        break;
      }
    }

    //#YVR If the ip is not present in tracker

    if (index == IP_TRACKER_COUNT) {

        for (index=0; index<IP_TRACKER_COUNT; index++) {
            if (trackers[index].lru == (IP_TRACKER_COUNT-1))
                break;
        }
        if(index == 64){
          cout<<"Wrong !!!!"<<endl;
        }
        
        trackers[index].ip = ip;
        trackers[index].last_cl_addr = cl_addr;
        trackers[index].last_stride = 0;
        trackers[index].conf = 0;

        for (int i=0; i<IP_TRACKER_COUNT; i++) {
            if (trackers[i].lru < trackers[index].lru)
                //std::min(conf + 1, 3);
                //trackers[i].lru++;
                trackers[i].lru = std::min(trackers[i].lru +1, IP_TRACKER_COUNT-1);
        }
        trackers[index].lru = 0;

        return ;  //#YVR what to return?
    }

    // sanity check
    // at this point we should know a matching tracker index
    if (index == -1)
        assert(0);

    int64_t stride = 0;
    if (cl_addr > trackers[index].last_cl_addr)
        stride = cl_addr - trackers[index].last_cl_addr;
    else {
        stride = trackers[index].last_cl_addr - cl_addr;
        stride *= -1;
    }
    

    if (stride == 0)
        return ;    //#YVR  Same Address so stride zero

    if (stride == trackers[index].last_stride) {
      trackers[index].conf += 1;
      if  (trackers[index].conf > 1) {
        // #YVR prefetching
        for (int i=0; i<PREFETCH_DEGREE; i++) {
            //prefetch the nex address by adding the stride in current address
            uint64_t pf_address = (cl_addr + (stride*(i+1))) << LOG2_BLOCK_SIZE;

            // only issue a prefetch if the prefetch address is in the same 4 KB page 
            // as the current demand access address
            if ((pf_address >> LOG2_PAGE_SIZE) != (addr >> LOG2_PAGE_SIZE))
                break;

            prefetch_line(ip, addr, pf_address, FILL_L1, 0);
            
        }
      }
    }
    //#YVR we have to update the value of the other tracker's lru to ++1 and current tracker to 0
    trackers[index].last_cl_addr = cl_addr;
    trackers[index].last_stride = stride;

    for (int i=0; i<IP_TRACKER_COUNT; i++) {
        if (trackers[i].lru < trackers[index].lru)
            trackers[i].lru = std::min(trackers[i].lru +1, IP_TRACKER_COUNT-1);
    }
    trackers[index].lru = 0;

    // prefetch_line(ip, addr, pf_address, FILL_L1, 0);

    return;
}

// ------------------------- DO NOT CHANGE -------------------------------- //
void CACHE::l1d_prefetcher_cache_fill(uint64_t v_addr, uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t v_evicted_addr, uint64_t evicted_addr, uint32_t metadata_in)
{
	return;
}

void CACHE::l1d_prefetcher_final_stats()
{
	cout << "CPU " << cpu << " L1D IP-based stride prefetcher final stats" << endl;
	cout << "Degree: " << PREFETCH_DEGREE << endl;
}
// ------------------------- DO NOT CHANGE -------------------------------- //