#include "cache.h"
#include "ooo_cpu.h" //preet

// ------------------------- DO NOT CHANGE -------------------------------- //
#define NUM_IP_TABLE_L1_ENTRIES 1024  // IP table entries
#define IP_TRACKER_COUNT 64           // Number of IP trackers
#define PREFETCH_DEGREE 5             // Prefetch degree
// ------------------------- DO NOT CHANGE -------------------------------- //

//extern CACHE* L1D; 
#define PHASE_LENGTH 1024                // Choose an appropriate phase length

uint64_t num_prefs = 0;               // To keep a track of the number of prefetched lines

uint64_t total_pf_useful =  0;         // #YVR To keep a track of the number of useful prefetches
uint64_t total_pf_lower_level  = 0;    // #YVR To keep a track of the number of prefetches that are lower level

uint16_t curr_pf_useful  = 0;           // #YVR To keep a track of the number of useful prefetches for current prefetch tech
uint16_t curr_pf_lower_level = 0;       // #YVR To keep a track of the number of prefetches that are lower level for current prefetch tech

double curr_accuracy = 0;
double best_accuracy = 0;

int flag=0;


// Track the accuracy of the different prefetchers
//double accuracy_ip;
//double accuracy_cplx;
//double accuracy_nl;

#define IP_STRIDE 1                   // IP-Stride Prefetcher
#define CPLX 2                        // Complex-Stride Prefetcher
#define NL 3                          // Next-line Prefetcher

uint16_t prefetcher = IP_STRIDE;      // Start with the IP-Stride Prefetcher
uint16_t final_prefetcher = 0;        //#YVR to be used after phased length

class IP_TRACKER {
  public:
    // ------------------------- Define the IP_TRACKER class here ------------------------- //
    uint64_t ip;
    uint64_t last_cl_addr;
    int64_t last_stride;
    int lru;
    int conf;        //confidence of stride

    IP_TRACKER(){
      ip=0;
      last_cl_addr=0;
      last_stride=0;
      lru=63;
      conf=0;
    }
    
};

IP_TRACKER trackers[IP_TRACKER_COUNT];

class IP_TABLE_CPLX {
  public:
    uint64_t ip_tag;
    uint64_t last_page;                 // last page seen by IP
    uint64_t last_cl_offset;            // last cl offset in the 4KB page
    int64_t last_stride;                // last delta observed
    uint16_t ip_valid;                  // valid IP or not   
    int conf;                           // CPLX conf
    uint16_t signature;                 // CPLX signature
    int stride;                         // Stride

    IP_TABLE_CPLX () {
        ip_tag = 0;
        last_page = 0;
        last_cl_offset = 0;
        last_stride = 0;
        ip_valid = 0;
        signature = 0;
        conf = 0;
        stride = 0;
    };
};

IP_TABLE_CPLX trackers_cplx[NUM_CPUS][NUM_IP_TABLE_L1_ENTRIES];

// ------------------------- Updating the signature ---------------------------- // 
uint16_t update_sig_l1(uint16_t old_sig, int delta) {                           
    return (old_sig << 1) ^ (delta & 0x1);  // #YVR Shift and XOR with the last stride((Delta))
    //return old_sig;
}

// ------------------- Updating confidence for the CPLX class ------------------ // 
int update_conf(int stride, int pred_stride, int conf) {
    if (stride == pred_stride) {
        return std::min(conf + 1, 3); // Increment confidence, max value 3
    } else {
        return std::max(conf - 1, 0);  // Decrement confidence, min value 0
    }
    //return conf;
}

// ------------------------- Initialize the prefetcher ------------------------- // 
void CACHE::l1d_prefetcher_initialize() 
{
	cout << "CPU " << cpu << " L1D Optimized prefetcher" << endl;
    
}

// --------------- This is the main prefetcher operate function ---------------- // 
void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint8_t critical_ip_flag)//, int final_pref)
{
    uint64_t cl_addr = addr >> LOG2_BLOCK_SIZE;

    CACHE *L1D = &ooo_cpu[0].L1D;
    if (warmup_complete[0] == 1) {
        //Logic for Phased length
        if(prefetcher!=4 && flag==0){
            num_prefs++ ;    //#YVR To keep a track of the number of prefetched lines for the current phase
            if (num_prefs==PHASE_LENGTH){
                //cout << "PREET : ";
                //cout << L1D->NAME;
                //cout << " PREFETCH  REQUESTED: " << setw(10) << L1D->pf_requested << "  ISSUED: " << setw(10) << L1D->pf_issued;
                //cout << "  USEFUL: " << setw(10) << L1D->pf_useful << "  USELESS: " << setw(10) << L1D->pf_useless << endl;

                curr_pf_useful =  (L1D->pf_useful) - total_pf_useful;
                curr_pf_lower_level =  (L1D->pf_lower_level) - total_pf_lower_level;

                total_pf_useful = total_pf_useful  + curr_pf_useful;                //#YVR can be made with less overhead
                total_pf_lower_level = total_pf_lower_level + curr_pf_lower_level;  //#YVR same

                curr_accuracy = ((double)L1D->pf_useful*100/L1D->pf_lower_level);
                //cout<<"accuracy " <<curr_accuracy <<endl;

                if (curr_accuracy > best_accuracy)
                {
                    best_accuracy = curr_accuracy;
                    //cout << "best accuracy changed to" << best_accuracy << endl;
                    // cout << "changed final pref value to " << prefetcher << endl;
                    final_prefetcher = prefetcher;
                    //(L1D->pf_useful*100/L1D->pf_lower_level)
                }
                prefetcher++;       //#YVR Increament  the prefetcher after each phase
                num_prefs = 0;     // Reset the number of prefetched lines for the next phase
            }
        }
        if(prefetcher == 4){    //#YVR Each 
            prefetcher = final_prefetcher;
            flag=1;
        }
        //Phased length part end here

        if (prefetcher == IP_STRIDE) {
// IP-Stride Prefetcher
            // ------------------------ Add IP-Stride pf_address logic here ----------------------- //
            int index=-1;
            for(index=0;index<IP_TRACKER_COUNT;index++){
            if(trackers[index].ip == ip){                   //#YVR To check if the ip is present in the tracker or not
                break;
            }
            }

            //#YVR If the ip is not present in tracker

            if (index == IP_TRACKER_COUNT) {

                for (index=0; index<IP_TRACKER_COUNT; index++) {
                    if (trackers[index].lru == (IP_TRACKER_COUNT-1))
                        break;
                }
                trackers[index].ip = ip;
                trackers[index].last_cl_addr = cl_addr;
                trackers[index].last_stride = 0;
                trackers[index].conf = 0;

                for (int i=0; i<IP_TRACKER_COUNT; i++) {
                    if (trackers[i].lru < trackers[index].lru)
                        //trackers[i].lru++;
                        trackers[i].lru = std::min(trackers[i].lru +1, IP_TRACKER_COUNT-1); //#YVR TO limit the lru to 63 only

                }
                trackers[index].lru = 0;

                return ;  //#YVR what to return?
            }

            // sanity check
            // at this point we should know a matching tracker index
            if (index == -1)
                assert(0);

            int64_t stride = 0;
            if (cl_addr > trackers[index].last_cl_addr)
                stride = cl_addr - trackers[index].last_cl_addr;
            else {
                stride = trackers[index].last_cl_addr - cl_addr;
                stride *= -1;
            }
            

            if (stride == 0)
                return ;    //#YVR  Same Address so stride zero

            if (stride == trackers[index].last_stride) {
                trackers[index].conf += 1;
                if  (trackers[index].conf > 1) {
                    // #YVR prefetching
                    for (int i=0; i<PREFETCH_DEGREE; i++) {
                        //prefetch the nex address by adding the stride in current address
                        uint64_t pf_address = (cl_addr + (stride*(i+1))) << LOG2_BLOCK_SIZE;

                        // only issue a prefetch if the prefetch address is in the same 4 KB page 
                        // as the current demand access address
                        if ((pf_address >> LOG2_PAGE_SIZE) != (addr >> LOG2_PAGE_SIZE))
                            break;

                        prefetch_line(ip, addr, pf_address, FILL_L1, 0);
                        
                    }
                }
            }
            //#YVR we have to update the value of the other tracker's lru to ++1 and current tracker to 0
            trackers[index].last_cl_addr = cl_addr;
            trackers[index].last_stride = stride;

            for (int i=0; i<IP_TRACKER_COUNT; i++) {
                if (trackers[i].lru < trackers[index].lru)
                    trackers[i].lru = std::min(trackers[i].lru +1, IP_TRACKER_COUNT-1); //#YVR TO limit the lru to 63 only
            }
            trackers[index].lru = 0; 
                
            // prefetch_line(ip, addr, pf_address, FILL_L1, 0);
        }
        else if (prefetcher == CPLX) {
// Complex-Stride Prefetcher
            // --------------------- Add Complex-Stride pf_address logic here --------------------- //
            int index =-1;
            for (index = 0; index < NUM_IP_TABLE_L1_ENTRIES; index++) {
                if (trackers_cplx[cpu][index].ip_tag == ip) {
                    break;
                }
            }
            // #YVR If IP is not present, create a new entry
            if (index == NUM_IP_TABLE_L1_ENTRIES) {
                for (index = 0; index < NUM_IP_TABLE_L1_ENTRIES; index++) {
                    //cout<<trackers_cplx[cpu][index].ip_valid<<endl;
                    if (trackers_cplx[cpu][index].ip_valid == 0) {
                        trackers_cplx[cpu][index].ip_tag = ip;
                        trackers_cplx[cpu][index].last_cl_offset = cl_addr;
                        trackers_cplx[cpu][index].last_stride = 0;
                        trackers_cplx[cpu][index].signature = 0;
                        //trackers_cplx[cpu][index].conf = 0;  //normal
                        trackers_cplx[cpu][index].conf = 1;     //rrip
                        trackers_cplx[cpu][index].ip_valid = 1; // Mark as valid
                        return;
                    }
                }
                return; //#YVR No free slots found, nothing to do
            }
            //#YVR calculating the current stride
            int64_t stride = cl_addr - trackers_cplx[cpu][index].last_cl_offset;

            //if stide is equal to 0, No change in address, same instruction in a row, return nothing
            if (stride == 0) return; 

            //uint16_t old_signature = trackers_cplx[cpu][index].signature;
            //trackers_cplx[cpu][index].signature = update_sig_l1(old_signature, stride);

            //#YVR updating the signature
            trackers_cplx[cpu][index].signature = update_sig_l1(trackers_cplx[cpu][index].signature, stride);
            
            // Last stride of the ip (need this to call the update_conf func)
            //int predicted_stride = trackers_cplx[cpu][index].last_stride;             //#YVR - OVERHEAD
            //trackers_cplx[cpu][index].conf = update_conf(stride, predicted_stride, trackers_cplx[cpu][index].conf); 

            //normal type    
            trackers_cplx[cpu][index].conf = update_conf(stride, trackers_cplx[cpu][index].last_stride, trackers_cplx[cpu][index].conf);
            //rrip type
            //trackers_cplx[cpu][index].conf = update_conf(stride, trackers_cplx[cpu][index].last_stride, trackers_cplx[cpu][index].conf, cpu ,index);

            trackers_cplx[cpu][index].last_stride = stride; // Store last stride

            if (trackers_cplx[cpu][index].conf > 1) {   // #YVR Confidence threshold
                for (int i = 1; i <= PREFETCH_DEGREE; i++) {
                    uint64_t pf_address = (cl_addr + (stride * i)) << LOG2_BLOCK_SIZE;

                    // Ensure the prefetch address is within the same page
                    // only issue a prefetch if the prefetch address is in the same 4 KB page
                    // as the current demand access address
                    if ((pf_address >> LOG2_PAGE_SIZE) != (addr >> LOG2_PAGE_SIZE))
                        break;

                    prefetch_line(ip, addr, pf_address, FILL_L1, 0);
                }
            }
            
            // Update last access info
            trackers_cplx[cpu][index].last_cl_offset = cl_addr; 

            // prefetch_line(ip, addr, pf_address, FILL_L1, 0);
        }
        else if (prefetcher == NL) {
// Next-Line Prefetcher
            // ----------------------- Add Next-line pf_address logic here ------------------------ //
            for (int i=0; i<PREFETCH_DEGREE; i++) {
                uint64_t cl_addr = addr >> LOG2_BLOCK_SIZE;

                // ----------------------- Next-line logic ------------------------ // 
                uint64_t pf_address = (cl_addr + ((i+1))) << LOG2_BLOCK_SIZE;

                // only issue a prefetch if the prefetch address is in the same 4 KB page
                // as the current demand access address
                if ((pf_address >> LOG2_PAGE_SIZE) != (addr >> LOG2_PAGE_SIZE))
                    break;
                    
                prefetch_line(ip, addr, pf_address, FILL_L1, 0);
            } 
            // prefetch_line(ip, addr, pf_address, FILL_L1, 0);
        }
        else {
            assert(0);
        }
    }

	return;

}

// ------------------------- DO NOT CHANGE -------------------------------- //
void CACHE::l1d_prefetcher_notify_about_dtlb_eviction(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
    
}

void CACHE::l1d_prefetcher_cache_fill(uint64_t v_addr, uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t v_evicted_addr, uint64_t evicted_addr, uint32_t metadata_in)
{
    
}

void CACHE::l1d_prefetcher_final_stats()
{
	cout << "CPU " << cpu << " L1D optimized prefetcher final stats" << endl;
	cout << "Degree: " << PREFETCH_DEGREE << endl;
}
// ------------------------- DO NOT CHANGE -------------------------------- //